---
title: "Intersections_FutRes"
author: "Vincyane Badouard"
date: "16/12/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
rm(list = ls()) ; invisible(gc())
library(Maria)
library(sf)
library(dplyr)
library(nngeo)
library(ggplot2)
# set.seed(420)
```

# Trails

```{r}
MainTrail <- sf::st_linestring(matrix(c(286400, 582945,
                                        286400, 583250,
                                        286700, 583250,
                                        286700, 582945,
                                        286400, 582945) # the return
                                      ,ncol=2, byrow=TRUE))
pol1 <- list(matrix(c(286503, 583134,
                      286503, 583240,
                      286507, 583240,
                      286507, 583134,
                      286503, 583134) # the return
                    ,ncol=2, byrow=TRUE))
pol2 <- list(matrix(c(286650, 583134,
                      286650, 583240,
                      286654, 583240,
                      286654, 583134,
                      286650, 583134) # the return
                    ,ncol=2, byrow=TRUE))

PolList = list(pol1,pol2) #list of lists of numeric matrices
ScndTrail <- sf::st_multipolygon(PolList)
Trail <- st_union(MainTrail, ScndTrail) # Our trail will be MainTrail or ScndTrail
rm(MainTrail, ScndTrail, pol1, pol2, PolList)
```

# Inventory
```{r}
inventory <- addtreedim(inventorycheckformat(Paracou6_2016),
                        volumeparameters = ForestZoneVolumeParametersTable)

inventory <- suppressMessages(treeselection(inventory, objective = 20, scenario ="manual",
                                            fuel = "2", diversification = TRUE, specieslax = FALSE,
                                            objectivelax = TRUE, topography = DTMParacou, 
                                            plotslope = PlotSlope,
                                            speciescriteria = SpeciesCriteria,
                                            advancedloggingparameters = loggingparameters())$inventory)
```

# Future Reserve

```{r}
FutureReserveCrowns <- inventory %>% # create an object with future/reserve crowns only
  dplyr::filter(LoggingStatus == "future" | LoggingStatus == "reserve") %>%
  createcanopy() %>% # create all inventory crowns in the 'Crowns' column
  getgeometry(Crowns)
```

# Individual
```{r}
ind <- inventory %>%
  dplyr::filter(Selected == "1") %>%
  dplyr::select(idTree,DBH,TrunkHeight,TreeHeight,CrownHeight,
                CrownDiameter,Selected, Xutm, Yutm) %>% 
  sample_n(1) %>% 
  tibble::add_column(TreeFellingOrientationSuccess = "1")

```

# Individual geometry

```{r}
# The Foot 
Foot <- st_point(c(ind$Xutm,ind$Yutm))

# The crown
Crown <- ind %>%
  mutate(xCrown = Xutm,
         yCrown = Yutm + TrunkHeight + CrownHeight/2,
         exCrown = CrownDiameter/2,
         eyCrown = CrownHeight/2) %>%
  st_as_sf(coords = c("xCrown", "yCrown")) # ellipse centroid coordinates
Crown <- st_ellipse(Crown, Crown$exCrown, Crown$eyCrown) # create the ellipse

# The trunk
Trunk <- with(ind,
              st_polygon(list(matrix(c(Xutm-(DBH/100)/2, Yutm,
                                       Xutm-(DBH/100)/2, Yutm + TrunkHeight,
                                       Xutm+(DBH/100)/2, Yutm + TrunkHeight,
                                       Xutm+(DBH/100)/2, Yutm,
                                       Xutm-(DBH/100)/2, Yutm) # the return
                                     ,ncol=2, byrow=TRUE))))

# Find the point (TrailPt) on the Trail closest to the location of the tree (Foot)
NearestPoints <- st_nearest_points(Foot, Trail) # from the Foot of the tree to the Trail (linestring)

NearestPoint <- st_cast(NearestPoints, "POINT") # to have start (Foot) and end (TrailPt) points
TrailPt <- NearestPoint[[2]] # the point (TrailPt) on the Trail closest to the location of the tree (Foot)
rm(NearestPoint)
```

# Angles
```{r}
# Compute the angle between the tree default position and the shortest way from the foot to the trail
## Right-hand trail
if(TrailPt[1] >= Foot[1]){ # x trail > x foot
  theta <- as.numeric(matlib::angle(c(Foot[1] - Foot[1], ind$TreeHeight),
                                    c(TrailPt[1] - Foot[1], TrailPt[2] - Foot[2]), degree = TRUE))
  ## Left-hand trail
}else if(TrailPt[1] < Foot[1]){ # x trail < x foot
  theta <- 180 - as.numeric(matlib::angle(c(Foot[1] - Foot[1], ind$TreeHeight),
                                          c(TrailPt[1] - Foot[1], TrailPt[2] - Foot[2]), degree = TRUE))
}

## when the tree is on the trail (no angle)
if(is.na(theta)) theta <- 0
thetaIndNearest <- theta
rm(theta)

TreefallOrientation <- as.numeric(c(1:179))
OppAng <- 180-(90 + TreefallOrientation)

## Right-hand trail
if(TrailPt[1] >= Foot[1]){ # x trail > x foot
  Aangle <- round(as.numeric(180 + OppAng + thetaIndNearest), digits = 0) # Foot oriented
  ## Left-hand trail
}else if(TrailPt[1] < Foot[1]){ # x trail < x foot
  Aangle <- round(as.numeric(360 - OppAng + thetaIndNearest), digits = 0) # Foot oriented
}

```

# Felling function

```{r}
felling0angle <- function(theta){
  # Calculate the crown and trunk position
  FallenTree <- st_difference(st_union(
    rotatepolygon(Trunk, angle = theta, fixed = Foot), # turned trunk
    rotatepolygon(Crown, angle = theta, fixed = Foot) # turned crown
  ))
  return(FallenTree)
}  
```

# Available felling positions

```{r}
AvailableFellingPositions <- lapply(as.list(Aangle), felling0angle) %>% 
  lapply(function(x) data.frame(Tree = x)) %>% 
  bind_rows()
# rm(TreefallOrientation, OppAng, Aangle)
```

# Overlaps with future/reserve trees

```{r}
overlaps <- st_intersects(AvailableFellingPositions$geometry,
                          summarise(FutureReserveCrowns, Crowns = st_combine(Crowns))$Crowns) %>% 
  lengths()

# if there are any position without intersection
if(any(overlaps == 0)){
EmptyFellingPositions <- AvailableFellingPositions %>% 
  mutate(overlaps = overlaps) %>% 
  filter(overlaps == 0) # only positions without intesection

# if there are no position without intersection
}else{
  EmptyFellingPositions <- AvailableFellingPositions # take all the positions
}
# rm(overlaps)
```
## In intersections case
```{r}
intersections <- st_intersection(AvailableFellingPositions$geometry,
                          summarise(FutureReserveCrowns, Crowns = st_combine(Crowns))$Crowns)

ggplot() +
  geom_sf(data = intersections)
```

```{r}
ggplot() +
  geom_sf(data = Trail) +
  geom_sf(data = AvailableFellingPositions$geometry, col = "grey") +
  geom_sf(data = EmptyFellingPositions$geometry, col = "blue") +
  geom_sf(data = Foot) +
  geom_sf(data = NearestPoints) +
  geom_sf(data = TrailPt) +
  geom_sf(data = Crown) +
  geom_sf(data = Trunk) +
  geom_sf(data = FutureReserveCrowns$Crowns, col = "green")
```

# Sample only one position

```{r}
FellingPosition <- sample_n(EmptyFellingPositions, 1)
```

```{r}
ggplot() +
  geom_sf(data = Trail) +
  geom_sf(data = AvailableFellingPositions$geometry, col = "grey") + # [1;180]
  geom_sf(data = EmptyFellingPositions$geometry, col = "blue") + # avoid av/res
  geom_sf(data = FellingPosition$geometry, col = "red") + # the final position
  geom_sf(data = Foot) +
  geom_sf(data = NearestPoints) +
  geom_sf(data = TrailPt) +
  geom_sf(data = Crown) +
  geom_sf(data = Trunk) +
  geom_sf(data = FutureReserveCrowns$Crowns, col = "green")
```
